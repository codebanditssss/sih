 import * as React from "react" import * as ReactDOM from "react-dom/client" import * as Framer from "framer" const routes = {r9YoYhwug: {elements: {EFMSWTooW: "features", qqgoXkyfn: "hero"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/ycUNjeziG5BZozvyPOWN/6YenZj3KZhiz0QKMiJ5f/r9YoYhwug.js")),
path: "/"}, X5XTPYk3J: {elements: {G6RvzEOU1: "hero"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/tWY2dCXyyJ6nD7wAmAWA/TvC2zV8JhgijMuA9AReM/X5XTPYk3J.js")), path: "/hero-2"}, VxPHZMt40: {elements: {fXfcDW9AK: "hero"}, page:
Framer.lazy(() => import("https://framerusercontent.com/modules/aMGK1YU3oLM1GSNCTPl5/BBVPcQRJQKZ8oBUQ8ZGB/VxPHZMt40.js")), path: "/hero-3"}, A9KV_QKlO: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/3k431AVhbZpQtAwgpSxB/Y6LF7o4FVhZ95EY61Zt5/A9KV_QKlO.js")),
path: "/404"}, L0wmlUYOQ: {elements: {yIItJ3ROx: "faqs"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/zRwcjHvgvZI6hBD2Ieeg/qo0w9S06SGexG8h921Dw/L0wmlUYOQ.js")), path: "/pricing"}, jsfNNqOwB: {elements: {}, page: Framer.lazy(()
=> import("https://framerusercontent.com/modules/3QCEwXERCpDo8q8Mxc2l/DO9hUKt5gpRKU3fV4Q5K/jsfNNqOwB.js")), path: "/terms-conditions"}, DVzy2K7f1: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/vn2gKWtNPC7cwa9in3Ra/NHaGLwnOTfjSHaoxBaYZ/DVzy2K7f1.js")),
path: "/privacy-policy"}, SYTWdDmlK: {elements: {O2L3b6jX7: "faqs"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/44FQUnrQOtMXq5MujcCM/6wm98pYXTMDSmVeeFfZO/SYTWdDmlK.js")), path: "/contact"}, s4S12Qeoo: {elements: {WTUCWan6j:
"faqs"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/fQij57GSCU2a5qUN48W6/42BGHZBDIIw8Trn93kkO/s4S12Qeoo.js")), path: "/blog"}, pDjQxmMxu: {collectionId: "FPaELuZmm", elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/9aKkxHCBnWIeQsyIrWjd/YnqyQsg2hTMsF0LkytNM/pDjQxmMxu.js")),
path: "/blog/:jgq81JLe3"}} const locales = [{code: "en-US", id: "default", name: "English", slug: ""}] export async function getPageRoot({ routeId, pathVariables, localeId }) { // We don't want the initial render to immediately have to suspend. await
routes[routeId].page.preload() const content = React.createElement( Framer.PageRoot, { isWebsite: true, routeId, pathVariables, routes, collectionUtils: {FPaELuZmm: async () => (await import("https://framerusercontent.com/modules/20ulH7ljslgzBdruLi9P/srL7X1kTZ0SVADUJ2apS/FPaELuZmm.js"))?.["utils"]},
framerSiteId: "472b668d94eb0ee9dda3065d6d6e670a8d26c7ad9de24e73a042f3b1be41450e", notFoundPage: Framer.lazy(() => import("https://framerusercontent.com/modules/3k431AVhbZpQtAwgpSxB/Y6LF7o4FVhZ95EY61Zt5/A9KV_QKlO.js")), isReducedMotion: undefined, localeId,
locales, preserveQueryParams: undefined, } ) const contentWithFeaturesContext = React.createElement( Framer.LibraryFeaturesProvider, { children: content, value: {enableAsyncURLUpdates: false, useGranularSuspense: false} } ) const effect = {enter: {mask:
{angle: 180, type: "wipe", width: "100%"}, opacity: 1, rotate: 0, rotate3d: false, rotateX: 0, rotateY: 0, scale: 1, transition: {damping: 30, delay: 0, duration: 0.4, ease: [0.27, 0, 0.51, 1], mass: 1, stiffness: 400, type: "tween"}, x: "0px", y: "0px"}}
const page = React.createElement(Framer.PageEffectsProvider, { children: contentWithFeaturesContext, value: {global: {enter: {mask: {angle: 90, type: "wipe", width: "100%"}, opacity: 1, rotate: 0, rotate3d: false, rotateX: 0, rotateY: 0, scale: 1, transition:
{damping: 30, delay: 0, duration: 0.4, ease: [0.27, 0, 0.51, 1], mass: 1, stiffness: 400, type: "tween"}, x: "0px", y: "0px"}}, routes: {pDjQxmMxu: {r9YoYhwug: effect}}} }) return page } const isBrowser = typeof document !== "undefined" if (isBrowser)
{ window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => () => { return React.createElement(Framer.ErrorPlaceholder, { error: 'Package component not supported: "' + exportIdentifier + '" in "' + packageAndFilename + '"' }) } //
A lot of libraries assume process.env.NODE_ENV is present in runtime/buildtime, so we are polyfilling it window.process = { ...window.process, env: { ...(window.process ? window.process.env: undefined), NODE_ENV: "production" } } window.__framer_events
= window.__framer_events || [] // Fallback support for stack gaps Framer.installFlexboxGapWorkaroundIfNeeded() const container = document.getElementById("main") // We know that #main is parsed before this script, so we don't need to wait for DOMContentLoaded
or similar events. if ("framerHydrateV2" in container.dataset) main(true, container) else main(false, container) } function track() { if (!isBrowser) return window.__framer_events.push(arguments) } async function main(shouldHydrate, container) { try {
let routeId, localeId, pathVariables, breakpoints if (shouldHydrate) { const routeData = JSON.parse(container.dataset.framerHydrateV2) routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables breakpoints = routeData.breakpoints
} else { const routeData = Framer.inferInitialRouteFromPath(routes, decodeURIComponent(location.pathname), true, locales) routeId = routeData.routeId localeId = routeData.localeId pathVariables = routeData.pathVariables } const page = await getPageRoot({
routeId, localeId, pathVariables }) function handleRecoverableError(error, errorInfo) { const componentStack = errorInfo?.componentStack console.warn("Recoverable error during hydration. Please check any custom code or code overrides to fix server/client
mismatches.", error, componentStack) // we only want to collect 1%, because this can be quite noisy (floods the data pipeline) if (Math.random() > 0.01) return track("published_site_load_recoverable_error", { message: String(error), componentStack, //
componentStack is more useful stack: componentStack ? undefined : error instanceof Error && typeof error.stack === "string" ? error.stack : null, }) } if (shouldHydrate) { Framer.withPerformanceMarks("framer-rewrite-breakpoints", () => { Framer.removeHiddenBreakpointLayersV2(breakpoints)
window.__framer_onRewriteBreakpoints?.(breakpoints) }) React.startTransition(() => { Framer.markHydrationStart() Framer.setInitialHydrationState() if (true) Framer.turnOffReactEventHandling() ReactDOM.hydrateRoot(container, page, { onRecoverableError:
handleRecoverableError }) }) } else { ReactDOM.createRoot(container, { onRecoverableError: handleRecoverableError }).render(page) } } catch (error) { track("published_site_load_error", { message: String(error), stack: error instanceof Error && typeof
error.stack === "string" ? error.stack : null }) throw error } } ;(function () { if (!isBrowser) return React.startTransition(() => { ReactDOM.createRoot(document.getElementById("__framer-badge-container")).render(React.createElement(React.Suspense, {},
React.createElement(Framer.withStyleAppearEffect(Framer.Container), { className: "__framer-badge", __framer__threshold: 0.5, __framer__animateOnce: true, __framer__opacity: 0, __framer__targetOpacity: 1, __framer__rotate: 0, __framer__x: 0, __framer__y:
10, __framer__scale: 1, __framer__transition: { "type": "spring", "ease": [0.44, 0, 0.56, 1], "duration": 0.3, "delay": 1, "stiffness": 350, "damping": 40, "mass": 1.5 }, __framer__rotateX: 0, __framer__rotateY: 0, __framer__perspective: 1200, }, React.createElement(React.lazy(()
=> import("__framer-badge"))) ) )) }) })()